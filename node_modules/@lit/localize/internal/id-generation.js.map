{"version":3,"file":"id-generation.js","sourceRoot":"","sources":["../src/internal/id-generation.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,OAAO,EAAC,MAAM,cAAc,CAAC;AAErC;;;;;GAKG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,MAAM,CAAC;AAErC;;;GAGG;AACH,MAAM,WAAW,GAAG,GAAG,CAAC;AAExB;;;GAGG;AACH,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACH,MAAM,UAAU,aAAa,CAC3B,OAAiD,EACjD,YAAqB;IAErB,OAAO,CACL,CAAC,YAAY,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,aAAa,CAAC;QAC5C,OAAO,CACL,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CACrE,CACF,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {fnv1a64} from './fnv1a64.js';\n\n/**\n * Delimiter used between each template string component before hashing. Used to\n * prevent e.g. \"foobar\" and \"foo${baz}bar\" from sharing a hash.\n *\n * This is the \"record separator\" ASCII character.\n */\nexport const HASH_DELIMITER = '\\x1e';\n\n/**\n * Id prefix on html-tagged templates to distinguish e.g. `<b>x</b>` from\n * html`<b>x</b>`.\n */\nconst HTML_PREFIX = 'h';\n\n/**\n * Id prefix on plain string templates to distinguish e.g. `<b>x</b>` from\n * html`<b>x</b>`.\n */\nconst STRING_PREFIX = 's';\n\n/**\n * Generate a unique ID for a lit-localize message.\n *\n * Example:\n *   Template: html`Hello <b>${who}</b>!`\n *     Params: [\"Hello <b>\", \"</b>!\"], true\n *     Output: h82ccc38d4d46eaa9\n *\n * The ID is constructed as:\n *\n *   [0]    Kind of template: [h]tml or [s]tring.\n *   [1,16] 64-bit FNV-1a hash hex digest of the template strings, as UTF-16\n *          code points, delineated by an ASCII \"record separator\" character.\n *\n * We choose FNV-1a because:\n *\n *   1. It's pretty fast (e.g. much faster than SHA-1).\n *   2. It's pretty small (0.25 KiB minified + brotli).\n *   3. We don't require cryptographic security, and 64 bits should give\n *      sufficient collision resistance for any one application. Worst\n *      case, we will always detect collisions during analysis.\n *   4. We can't use Web Crypto API (e.g. SHA-1), because it's asynchronous.\n *   5. It's a well known non-cryptographic hash with implementations in many\n *      languages.\n *   6. There was an existing JavaScript implementation that doesn't require\n *      BigInt, for IE11 compatibility.\n */\nexport function generateMsgId(\n  strings: string | string[] | TemplateStringsArray,\n  isHtmlTagged: boolean\n): string {\n  return (\n    (isHtmlTagged ? HTML_PREFIX : STRING_PREFIX) +\n    fnv1a64(\n      typeof strings === 'string' ? strings : strings.join(HASH_DELIMITER)\n    )\n  );\n}\n"]}